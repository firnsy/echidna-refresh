#!/usr/bin/perl
#
#
#

use warnings;
use strict;

use 5.010;

#
# PERL INCLUDES
#
use Data::Dumper;
use DBD::mysql;
use DBI;
use Digest::SHA qw(sha256_hex);
use Mojo::JSON;
use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::UserAgent;

#
# GLOBALS
#

#
# CONFIGURATION
#

my $CONF = {
  network => {
    host => 'localhost',
    port => 6969,
  },
  auth => {
    secret => 'woot',
    key    => 'abce',
  },
  cxtracker => {
    dir  => '/var/log/cxtracker',
    regex => 'stats.*',
    poll => 10,
  },
};


#
# HELPERS
#

=head2 _get_sessions

 This sub extracts the session data from a session data file.
 Takes $file as input parameter.

=cut

sub _get_sessions {
  my ($sfile, $node_id) = @_;

  my $sessions_data = [];

  say('D: Session file found: ' . $sfile);

  if( open(FILE, $sfile) )
  {
    my $cnt = 0;
    # verify the data in the session files
    while( my $line = readline FILE )
    {
      chomp $line;
      $line =~ /^\d{19}/;
      unless($line)
      {
        say('E: Not valid session start format in: ' . $sfile);
        next;
      }

      my @elements = split(/\|/, $line);

      unless(@elements == 15)
      {
        say('E: Not valid number of session args format in: ' . $sfile);
        next;
      }

      # build the session structs
      push( @{ $sessions_data }, {
        id                    => $elements[0],
        timestamp             => 0,
        time_start            => $elements[1],
        time_end              => $elements[2],
        time_duration         => $elements[3],
        node_id               => $node_id,
        net_version           => 4,
        net_protocol          => $elements[4],
        net_src_ip            => $elements[5],
        net_src_port          => $elements[6],
        net_src_total_packets => $elements[9],
        net_src_total_bytes   => $elements[10],
        net_src_flags         => $elements[13],
        net_dst_ip            => $elements[7],
        net_dst_port          => $elements[8],
        net_dst_total_packets => $elements[11],
        net_dst_total_bytes   => $elements[12],
        net_dst_flags         => $elements[14],
        data_filename         => 'filename.ext',
        data_offset           => 0,
        data_length           => 0,
        meta_cxt_id           => $elements[0],
      });
    }

    close FILE;

    return $sessions_data;
  }
}

sub _process {
  my $dir = $CONF->{cxtracker}{dir};
  my $regex = $CONF->{cxtracker}{regex};
  say('D: Checking dir: ' . $dir);

  if( opendir my $dh, $dir )
  {
    while( my $file = readdir($dh) )
    {
      if( -f "$dir/$file" and $file =~ /$regex/)
      {
        $file = $dir . '/' . $file;

        if( ! ( -r -w -f $file ) )
        {
          say('I: Insufficient permissions to operate on file: ' . $file);
          return;
        };

        say('I: Found file: ' . $file);

        my ($sessions, $start_time, $end_time, $process_time, $result);

        $start_time   = time();
        $sessions     = _get_sessions($file, $CONF->{_session_key});
        $end_time     = time();
        $process_time = $end_time - $start_time;
        say('D: File ' . $file . ' processed in ' . $process_time . ' seconds');
        $start_time   = time();

        if( @{ $sessions } )
        {
          for my $session ( @{ $sessions } )
          {
            say("Posting to: " . $CONF->{_session_uri} . '/api/sessions');

            $CONF->{_ua}->post_json($CONF->{_session_uri} . '/api/sessions' => $session => sub {
              my ($ua, $tx) = @_;
              say $tx->res->code();
            });
          }

          $end_time     = time();
          $process_time = $end_time - $start_time;

          say('D: Session record(s) sent in ' . $process_time . ' seconds');
        }

#        if( ! unlink($file) )
#        {
#          say('E: Failed to delete: ' . $file);
#        }
      }
    }
    closedir($dh);
  }
  else
  {
    say('D: Could not open ' . $dir);
  }
}

sub _process_start {
  if( defined($CONF->{_cxtracker}{process_timer}) )
  {
    say("D: already processing.");
    return;
  }

  $CONF->{_ua} = Mojo::UserAgent->new();

  # TODO: fanotify based watcher
  # establish the poll process
  $CONF->{_cxtracker}{process_timer} = Mojo::IOLoop->recurring($CONF->{cxtracker}{poll}, sub {
    _process();
  });

  say Dumper($CONF);

  _process();
}

sub _process_stop {

  if( ! defined($CONF->{_cxtracker}{process_timer}) )
  {
    say("D: not processing.");
    return;
  }

  say("Stopping...");
  Mojo::IOLoop->remove( $CONF->{_cxtracker}{process_timer} );
  delete( $CONF->{_cxtracker}{process_timer} );

  delete( $CONF->{_ua} );

}


#
# WEBSOCKET
#

websocket '/echo' => sub {
  my $self = shift;

  #Connected
  $self->app->log->debug('WebSocket connected.');

  # Increase inactivity timeout for connection a bit
  Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

  # Incoming message
  $self->on(message => sub {
    my ($self, $msg) = @_;

    my $json = Mojo::JSON->new();

    eval {
      $msg = $json->decode($msg);
    };

    if( $@ ) {
      say("E: unable to decode message: ", Dumper( $msg ) );
    }

    my $res = {
      type => $msg->{type} //= 'unknown'
    };

    given( $msg->{type} )
    {
      when('auth_request')
      {
        $msg->{nonce} //= '';

        if( $msg->{nonce} eq '' )
        {
          $res->{status} = 500;
        }
        else
        {
          $res->{hmac} = sha256_hex( $msg->{nonce} . $CONF->{auth}{secret} );
          $res->{status} = 200;
        }
      }
      when('auth_validate')
      {
        $CONF->{_session_key} = $msg->{session_key};
        $CONF->{_session_uri} = $msg->{session_uri};
        $res->{status} = 200;

        say('Session key granted: ' . $CONF->{_session_key} . ' (' . $CONF->{_session_uri} . ')');

        _process_start();
      }
      when('ping')
      {
        $res->{time} = time(),
        $res->{stt} = $msg->{time} - $res->{time}
      }
      default {
        say Dumper($msg);
      }
    }

    $self->send( $json->encode( $res ) );
  });

  # Disconnected
  $self->on(finish => sub {
    my $self = shift;
    $self->app->log->debug('WebSocket disconnected.');
    _process_stop();
  });

  $self->on(error => sub {
    my $self = shift;
    say( Dumper( $@ ) ); 
    $self->app->log->debug('ERROR');
    #_process_stop();
  });
};

#
# ROUTES
#




#
# INIT
#
app->config(hypnotoad => {listen => ['http://' . $CONF->{network}{host} . '/' . $CONF->{network}{port}]});

app->secret('cxtrackerd');
app->start();

