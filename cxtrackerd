#!/usr/bin/perl
#
#
#

use warnings;
use strict;

use 5.010;

#
# PERL INCLUDES
#
use Data::Dumper;
use DBD::mysql;
use DBI;
use Digest::SHA qw(sha256_hex);
use File::Basename;
use File::Copy;
use Mojo::JSON;
use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::UserAgent;

#
# GLOBALS
#

#
# CONFIGURATION
#

my $CONF = {
  network => {
    host => 'localhost',
    port => 6969,
  },
  auth => {
    secret => 'woot',
    key    => 'abce',
  },
  cxtracker => {
    dir      => './logs/cxtracker',
    mode     => 'archive',
    archive  => './logs/cxtracker/archive',
    regex    => 'stats.*',
    poll     => 10,
  },
};


#
# HELPERS
#

=head2 _get_sessions

 This sub extracts the session data from a session data file.
 Takes $file as input parameter.

=cut

sub _get_sessions {
  my ($sfile, $node_id) = @_;

  my $sessions_data = [];

  say('D: Session file found: ' . $sfile);

  if( open(FILE, $sfile) )
  {
    my $cnt = 0;
    # verify the data in the session files
    while( my $line = readline FILE )
    {
      chomp $line;
      $line =~ /^\d{19}/;
      unless($line)
      {
        say('E: Invalid session start format in: ' . $sfile);
        next;
      }

      my @elements = split(/\|/, $line);

      my $data_filename = '';
      my $data_offset = 0;
      my $data_length = 0;

      if( @elements == 15 )
      {
        say('D: No indexing available for session.');
      }
      elsif( @elements == 18 )
      {
        $data_filename = $elements[15];
        $data_offset   = $elements[16];
        $data_length   = $elements[17];
      }
      else
      {
        say('E: Not valid number of session args format in: ' . $sfile);
        next;
      }

      # build the session structs
      push( @{ $sessions_data }, {
        id                    => $elements[0],
        timestamp             => $elements[1],
        time_start            => $elements[1],
        time_end              => $elements[2],
        time_duration         => $elements[3],
        node_id               => $node_id,
        net_version           => 4,
        net_protocol          => $elements[4],
        net_src_ip            => $elements[5],
        net_src_port          => $elements[6],
        net_src_total_packets => $elements[9],
        net_src_total_bytes   => $elements[10],
        net_src_flags         => $elements[13],
        net_dst_ip            => $elements[7],
        net_dst_port          => $elements[8],
        net_dst_total_packets => $elements[11],
        net_dst_total_bytes   => $elements[12],
        net_dst_flags         => $elements[14],
        data_filename         => $data_filename,
        data_offset           => $data_offset,
        data_length           => $data_length,
        meta_cxt_id           => $elements[0],
      });
    }

    close FILE;

    return $sessions_data;
  }
}

sub _cleanup_inserted {
  my $file = shift;

  my $mode = $CONF->{cxtracker}{mode} //= 'delete';

  if( $mode eq 'archive' )
  {
    my $destination = $CONF->{cxtracker}{archive} . '/' . basename( $file );
    say("D: Archiving " . $file . " -> " . $destination);

    if( -d $CONF->{cxtracker}{archive} )
    {

      if( ! move( $file, $destination ) )
      {
        say('E: Unable to archive: ' . $file);
      }
    }
    else
    {
      say('E: Archive directory does not exist!');
    }
  }
  else
  {
    say('D: Deleting ' . $file);

    if( ! unlink($file) )
    {
      say('E: Failed to delete: ' . $file);
    }
  }
}


sub _cleanup_check {
  $CONF->{_files} //= {};

  for my $f ( keys( %{ $CONF->{_files} } ) )
  {
    my $stats = $CONF->{_files}{$f};

    if( $stats->{count} == $stats->{insert} )
    {
      delete( $CONF->{_files}{$f} );
      _cleanup_inserted($f);
    }
    elsif( $stats->{count} == $stats->{duplicate} )
    {
      delete( $CONF->{_files}{$f} );
      _cleanup_inserted($f);
    }
  }
}

sub _process {
  my $dir = $CONF->{cxtracker}{dir};
  my $regex = $CONF->{cxtracker}{regex};

  say('D: Checking dir: ' . $dir);

  if( opendir my $dh, $dir )
  {
    while( my $file = readdir($dh) )
    {
      if( -f "$dir/$file" and $file =~ /$regex/)
      {
        $file = $dir . '/' . $file;

        if( ! ( -r -w -f $file ) )
        {
          say('I: Insufficient permissions to operate on file: ' . $file);
          return;
        };

        say('I: Found file: ' . $file);

        my ($sessions, $start_time, $end_time, $process_time, $result);

        $start_time   = time();
        $sessions     = _get_sessions($file, $CONF->{_session_key});
        $end_time     = time();
        $process_time = $end_time - $start_time;
        say('D: File ' . $file . ' processed in ' . $process_time . ' seconds');
        $start_time   = time();

        $CONF->{_files}{$file} = {
          count     => scalar @{ $sessions },
          insert    => 0,
          duplicate => 0,
          fail      => 0,
        };

        if( @{ $sessions } )
        {
          for my $session ( @{ $sessions } )
          {
            say("Posting to: " . $CONF->{_session_uri} . '/api/sessions');

            $CONF->{_ua}->post_json($CONF->{_session_uri} . '/api/sessions' => $session => sub {
              my ($ua, $tx) = @_;
              #            say Dumper($tx);

              if( $tx->res->code() == 200 )
              {
                $CONF->{_files}{$file}{insert}++;
              }
              elsif( $tx->res->code() == 502 )
              {
                $CONF->{_files}{$file}{duplicate}++;
              }
              else
              {
                $CONF->{_files}{$file}{fail}++;
              }

              _cleanup_check();
            });
          }

          $end_time     = time();
          $process_time = $end_time - $start_time;

          say('D: Session record(s) sent in ' . $process_time . ' seconds');
        }
        else
        {
          _cleanup_check();
        }
      }
    }
    closedir($dh);
  }
  else
  {
    say('D: Could not open ' . $dir);
  }
}

sub _process_start {
  if( defined($CONF->{_cxtracker}{process_timer}) )
  {
    say("D: already processing.");
    return;
  }

  # TODO: fanotify based watcher
  # establish the poll process
  $CONF->{_cxtracker}{process_timer} = Mojo::IOLoop->recurring($CONF->{cxtracker}{poll}, sub {
    _process();
  });

  say Dumper($CONF);

  _process();
}

sub _process_stop {

  if( ! defined($CONF->{_cxtracker}{process_timer}) )
  {
    say("D: not processing.");
    return;
  }

  say("Stopping...");
  Mojo::IOLoop->remove( $CONF->{_cxtracker}{process_timer} );
  delete( $CONF->{_cxtracker}{process_timer} );
}


#
# WEBSOCKET
#

websocket '/control' => sub {
  my $self = shift;

  # connected
  $self->app->log->debug('WebSocket connected.');

  # Increase inactivity timeout for connection a bit
  Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

  # Incoming message
  $self->on(message => sub {
    my ($self, $msg) = @_;

    my $json = Mojo::JSON->new();

    eval {
      $msg = $json->decode($msg);
    };

    if( $@ ) {
      say("E: unable to decode message: ", Dumper( $msg ) );
    }

    my $res = {
      type => $msg->{type} //= 'unknown'
    };

    given( $msg->{type} )
    {
      when('auth_request')
      {
        $msg->{nonce} //= '';

        if( $msg->{nonce} eq '' )
        {
          $res->{status} = 500;
        }
        else
        {
          $res->{hmac} = sha256_hex( $msg->{nonce} . $CONF->{auth}{secret} );
          $res->{status} = 200;
        }
      }
      when('auth_validate')
      {
        $CONF->{_session_key} = $msg->{session_key};
        $CONF->{_session_uri} = $msg->{session_uri};
        $res->{status} = 200;

        say('Session key granted: ' . $CONF->{_session_key} . ' (' . $CONF->{_session_uri} . ')');

        _process_start();
      }
      when('ping')
      {
        $res->{time} = time(),
        $res->{stt} = $msg->{time} - $res->{time}
      }
      default {
        say Dumper($msg);
      }
    }

    $self->send( $json->encode( $res ) );
  });

  # Disconnected
  $self->on(finish => sub {
    my $self = shift;
    $self->app->log->debug('WebSocket disconnected.');
    _process_stop();
  });

  $self->on(error => sub {
    my $self = shift;
    say( Dumper( $@ ) );
    $self->app->log->debug('ERROR');
    #_process_stop();
  });
};

#
# ROUTES
#




#
# INIT
#


$CONF->{_ua} = Mojo::UserAgent->new();


app->config(hypnotoad => {listen => ['http://' . $CONF->{network}{host} . '/' . $CONF->{network}{port}]});

app->secret('cxtrackerd');
app->start();

