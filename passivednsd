#!/usr/bin/perl
#
# This file is part of the Echidna framework
#
# Copyright (C) 2010-2012, Edward Fjellsk√•l <edwardfjellskaal@gmail.com>
#                          Eduardo Urias    <windkaiser@gmail.com>
#                          Ian Firns        <firnsy@securixlive.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.  You may not use, modify or
# distribute this program under any other version of the GNU General
# Public License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

use warnings;
use strict;

use 5.010;

#
# PERL INCLUDES
#
use Data::Dumper;
use Digest::SHA qw(sha256_hex);
use Fcntl qw(SEEK_SET);
use File::Basename;
use File::Copy;
use List::Util qw(first);
use Mojo::JSON;
use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::UserAgent;

#
# GLOBALS
#

#
# CONFIGURATION
#

my $CONF = {
  host => 'localhost',
  port => 6967,
  key  => 'woot',
  passivedns => {
    dir      => './logs/passivedns',
    mode     => 'archive',
    archive  => './logs/passivedns/archive',
    regex    => '.*',
    poll     => 10,
  },
};


#
# HELPERS
#

=head2 _get_dns_records

 This sub extracts the DNS data from a passivedns data file.
 Takes $file as input parameter.

=cut

sub _get_dns_records {
  my ($spooler, $node_id) = @_;

  my $dns_data = [];

  if( -e $spooler->{file} ) {
    say('D: DNS record file found: ' . $spooler->{file});

    if( open(FILE, $spooler->{file}) )
    {
      # fast forward if offset is non-zero
      if( $spooler->{file_offset} > 0 ) {
        say 'D: Offsetting to ' . $spooler->{file_offset} . ' bytes.';
        seek FILE, $spooler->{file_offset}, SEEK_SET;
      }

      # verify the data in the dns data files
      while( my $line = readline FILE )
      {
        chomp $line;
        $line =~ /^\d{10}/;
        unless($line)
        {
          say('E: Invalid DNS start format in: ' . $spooler->{file});
          next;
        }

        my @elements = split(/\|\|/, $line);

        if( @elements != 8 )
        {
          say 'E: Unknown passivedns format detected.';
          next;
        }

        # build the dns structs
        push( @{ $dns_data }, {
          id                    => sha256_hex(@elements[0..2,4,6]),
          node_id               => $node_id,
          timestamp             => $elements[0],
          client                => $elements[1],
          server                => $elements[2],
          rr_class              => $elements[3],
          query                 => $elements[4],
          query_type            => $elements[5],
          answer                => $elements[6],
          ttl                   => $elements[7],
        });

        $spooler->{file_offset} = tell FILE;
      }

      close FILE;
    }
  }

  return $dns_data;
}

sub _cleanup {
  my $file = $CONF->{_spooler}{file};

  if( -e $file ) {
    my $mode = $CONF->{passivedns}{mode} //= 'delete';

    if( $mode eq 'archive' ) {
      my $destination = $CONF->{passivedns}{archive} . '/' . basename( $file );
      say 'D: Archiving ' . $file . ' -> ' . $destination;

      if( -d $CONF->{passivedns}{archive} ) {
        if( ! move( $file, $destination ) ) {
          say 'E: Unable to archive: ' . $file;
        }
      }
      else {
        say 'E: Archive directory does not exist!';
      }
    }
    else {
      say 'D: Deleting ' . $file;

      if( ! unlink($file) ) {
        say 'E: Failed to delete: ' . $file;
      }
    }
  }
  else {
    say 'D: nothing to clean.';
  }
}

sub _get_next_file {
  my ($spooler, $dir, $regex,) = @_;

  # return current file by default
  my $current_file = basename $spooler->{file};

  # check if our current file has grown first


  if( opendir my $dh, $dir ) {
    # collect all available files
    my @files = grep { /$regex/ && -f -r -w "$dir/$_" } readdir($dh);
    closedir($dh);

    # do we have files
    if( @files ) {
      # check for last file in list
      my $index = first { $files[$_] eq $current_file } 0..$#files;

      if( defined($index) ) {
        # no new files when index is last item
        if( $index == $#files ) {
          say 'D: No new files to process';
        }
        else {
          # clean up due to file change
          _cleanup();

          $spooler->{file} = $dir . '/' . $files[$index + 1];
          $spooler->{file_offset} = 0;
        }
      }
      # return first file in list if we didn't find our current
      else {
        # clean up due to file change
        _cleanup();

        $spooler->{file} = $dir . '/' . $files[0];
        $spooler->{file_offset} = 0;
      }

      say 'D: Next file is ' . $spooler->{file} . ', offsetted at ' . $spooler->{file_offset} . ' bytes.';
    }
    else {
      say 'D: No files available.';
    }
  }
  else {
    say 'D: Could not open ' . $dir;
  }
}

sub _flush_records {
  if( @{ $CONF->{_spooler}{records} } ) {
    # grab the record at the head of the list
    my $record = $CONF->{_spooler}{records}->[0];

    say 'D: Posting record to ' . $CONF->{_session_uri} . '/api/pdns (' . @{ $CONF->{_spooler}{records} } . ' in queue)';
    $CONF->{_ua}->post_json($CONF->{_session_uri} . '/api/pdns?session=' . $CONF->{_session_key} => $record => sub {
      my ($ua, $tx) = @_;

      my $tx_res_code = $tx->res->code // -1;

      if( $tx_res_code == 200 ) {
        # pop on success
        splice @{ $CONF->{_spooler}{records} }, 0, 1;
      }
      elsif( $tx_res_code == 502 ) {
        # pop on duplicate (it's already there)
        splice @{ $CONF->{_spooler}{records} }, 0, 1;
      }
      else {
        # indicate failure
        say 'E: Unable to push record.';
      }

      _flush_records()
    });
  }
  # otherwise continue processing
  else {
    _process();
  }
}

sub _process {
  my $dir = $CONF->{passivedns}{dir};
  my $regex = $CONF->{passivedns}{regex};

  say 'D: Checking dir: ' . $dir;

  # attempt to get mroe records is none exist
  if( ! @{ $CONF->{_spooler}{records} } ) {
    _get_next_file($CONF->{_spooler}, $dir, $regex);

    # add new records to cache
    push @{ $CONF->{_spooler}{records} }, @{ _get_dns_records($CONF->{_spooler}, $CONF->{_session_key} ) };
  }

  # check if we have sessions to flush
  if( @{ $CONF->{_spooler}{records} } ) {
    _flush_records();
  }
}

sub _process_start {
  if( defined($CONF->{_passivedns}{process_timer}) ) {
    say 'D: Already processing.';
    return;
  }

  # TODO: fanotify based watcher
  # establish the poll process
  $CONF->{_passivedns}{process_timer} = Mojo::IOLoop->recurring($CONF->{passivedns}{poll}, sub {
    _process();
  });

  _process();
}

sub _process_stop {

  if( ! defined($CONF->{_passivedns}{process_timer}) )
  {
    say 'D: Not processing.';
    return;
  }

  say 'D: Stopping processing ...';
  Mojo::IOLoop->remove( $CONF->{_passivedns}{process_timer} );
  delete( $CONF->{_passivedns}{process_timer} );
}


#
# WEBSOCKET
#

websocket '/control' => sub {
  my $self = shift;

  # connected
  $self->app->log->debug('WebSocket connected.');

  # Increase inactivity timeout for connection a bit
  Mojo::IOLoop->stream($self->tx->connection)->timeout(300);

  # Incoming message
  $self->on(message => sub {
    my ($self, $msg) = @_;

    my $json = Mojo::JSON->new();

    eval {
      $msg = $json->decode($msg);
    };

    if( $@ ) {
      say("E: unable to decode message: ", Dumper( $msg ) );
    }

    my $res = {
      type => $msg->{type} //= 'unknown'
    };

    given( $msg->{type} )
    {
      when('auth_request')
      {
        $msg->{nonce} //= '';

        if( $msg->{nonce} eq '' )
        {
          $res->{status} = 500;
        }
        else
        {
          $res->{hmac} = sha256_hex( $msg->{nonce} . $CONF->{key} );
          $res->{status} = 200;
        }
      }
      when('auth_validate')
      {
        $CONF->{_session_key} = $msg->{session_key};
        $CONF->{_session_uri} = $msg->{session_uri};
        $res->{status} = 200;

        say('Session key granted: ' . $CONF->{_session_key} . ' (' . $CONF->{_session_uri} . ')');

        _process_start();
      }
      when('ping')
      {
        $res->{time} = time(),
        $res->{stt} = $msg->{time} - $res->{time}
      }
      default {
        say Dumper($msg);
      }
    }

    $self->send( $json->encode( $res ) );
  });

  # Disconnected
  $self->on(finish => sub {
    my $self = shift;
    $self->app->log->debug('WebSocket disconnected.');
    _process_stop();
  });

  $self->on(error => sub {
    my $self = shift;
    say( Dumper( $@ ) );
    $self->app->log->debug('ERROR');
    #_process_stop();
  });
};

#
# ROUTES
#




#
# INIT
#


$CONF->{_ua} = Mojo::UserAgent->new();
$CONF->{_spooler} = {
  file        => '',
  file_offset => -1,
  records     => [],
};



app->config(hypnotoad => {listen => ['http://' . $CONF->{host} . '/' . $CONF->{port}]});

app->secret('passivednsd');
app->start();

